<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CrossRealm ‚Ä¢ On-Chain Chess on Core</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bitcoin-orange: #f7931a;
            --burnt-orange: #cc6600;
            --dark-bg: #0f0f0f;
            --card-bg: #1a1a1a;
            --border: #2a2a2a;
            --text: #e0e0e0;
            --text-dim: #999;
            --success: #00c851;
            --error: #ff4444;
        }

        body {
            font-family: 'Courier New', Courier, monospace;
            background: var(--dark-bg);
            color: var(--text);
            min-height: 100vh;
            padding: 20px;
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(247, 147, 26, 0.03) 2px, rgba(247, 147, 26, 0.03) 4px);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Header */
        .header {
            background: var(--card-bg);
            border: 2px solid var(--bitcoin-orange);
            border-radius: 0;
            padding: 25px;
            margin-bottom: 30px;
            position: relative;
            overflow: hidden;
        }

        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(247, 147, 26, 0.1), transparent);
            animation: shimmer 3s infinite;
        }

        @keyframes shimmer {
            0%, 100% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
        }

        .logo {
            font-size: 32px;
            font-weight: bold;
            color: var(--bitcoin-orange);
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 3px;
            position: relative;
            z-index: 1;
        }

        .tagline {
            color: var(--text-dim);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            position: relative;
            z-index: 1;
        }

        .wallet-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            flex-wrap: wrap;
            gap: 15px;
            position: relative;
            z-index: 1;
        }

        .wallet-status {
            font-size: 12px;
            color: var(--text-dim);
            padding: 8px 15px;
            border: 1px solid var(--border);
            background: rgba(0,0,0,0.3);
        }

        .wallet-address {
            color: var(--bitcoin-orange);
            font-weight: bold;
        }

        /* Buttons */
        button {
            background: linear-gradient(135deg, var(--bitcoin-orange), var(--burnt-orange));
            color: #000;
            border: none;
            padding: 12px 30px;
            font-family: inherit;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            overflow: hidden;
        }

        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover::before {
            width: 300px;
            height: 300px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(247, 147, 26, 0.3);
        }

        button:disabled {
            background: var(--border);
            color: var(--text-dim);
            cursor: not-allowed;
            opacity: 0.5;
        }

        button:disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .disconnect-btn, .resign-btn {
            background: linear-gradient(135deg, var(--bitcoin-orange), var(--burnt-orange));
            color: #000;
            text-shadow: 0 0 5px rgba(255, 68, 68, 0.8); /* Red glow on black text */
        }

        .claim-btn {
            background: var(--success);
            color: #000;
            margin-top: 10px;
        }

        /* Grid Layout */
        .grid {
            display: grid;
            grid-template-columns: 400px 1fr 400px;
            gap: 20px;
            margin-bottom: 30px;
        }

        @media (max-width: 1200px) {
            .grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 768px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        /* Cards */
        .card {
            background: var(--card-bg);
            border: 1px solid var(--border);
            padding: 25px;
        }

        .card-header {
            border-bottom: 2px solid var(--bitcoin-orange);
            padding-bottom: 15px;
            margin-bottom: 20px;
        }

        .card-title {
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--bitcoin-orange);
        }

        /* Chess Board */
        .chess-board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 0;
            max-width: 600px;
            margin: 0 auto;
            border: 3px solid var(--bitcoin-orange);
            aspect-ratio: 1;
        }

        .chess-square {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            touch-action: manipulation; /* Improve mobile touch */
        }

        .chess-square.light {
            background: #3a3a3a;
        }

        .chess-square.dark {
            background: #1a1a1a;
        }

        .chess-square:hover {
            background: rgba(247, 147, 26, 0.2);
        }

        .chess-square.selected {
            background: var(--burnt-orange);
            box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
        }

        .chess-square.valid-move {
            background: rgba(0, 200, 81, 0.3);
        }

        .chess-square.valid-move::after {
            content: '';
            position: absolute;
            width: 20%;
            height: 20%;
            background: var(--success);
            border-radius: 50%;
        }

        /* Game Controls */
        .game-controls {
            text-align: center;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }

        .game-status {
            font-size: 16px;
            margin-bottom: 10px;
            color: var(--bitcoin-orange);
        }

        .player-color {
            font-size: 14px;
            color: var(--success);
            margin-bottom: 5px;
            font-weight: bold;
        }

        /* Game List */
        .game-list {
            max-height: 500px;
            overflow-y: auto;
        }

        .game-item {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--border);
            padding: 15px;
            margin-bottom: 10px;
            transition: all 0.3s;
        }

        .game-item:hover {
            border-color: var(--bitcoin-orange);
            background: rgba(247, 147, 26, 0.1);
        }

        .game-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .game-id {
            color: var(--bitcoin-orange);
            font-weight: bold;
        }

        .game-stake {
            color: var(--text);
            font-size: 14px;
        }

        .game-player {
            color: var(--text-dim);
            font-size: 12px;
            margin-top: 5px;
        }

        /* Form Elements */
        input, select {
            width: 100%;
            padding: 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border);
            color: var(--text);
            font-family: inherit;
            font-size: 14px;
            margin-top: 8px;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--bitcoin-orange);
            background: rgba(247, 147, 26, 0.05);
        }

        label {
            color: var(--text);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: block;
            margin-bottom: 5px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        /* Alerts */
        .alert {
            padding: 15px;
            margin-bottom: 15px;
            border-left: 4px solid;
            background: rgba(0, 0, 0, 0.5);
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateX(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .alert-success {
            border-color: var(--success);
            color: var(--success);
        }

        .alert-error {
            border-color: var(--error);
            color: var(--error);
        }

        .alert-info {
            border-color: var(--bitcoin-orange);
            color: var(--bitcoin-orange);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--dark-bg);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--bitcoin-orange);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--burnt-orange);
        }

        /* Loading Spinner */
        .spinner {
            border: 3px solid var(--border);
            border-top: 3px solid var(--bitcoin-orange);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        /* Footer */
        .footer {
            text-align: center;
            padding: 30px 0;
            color: var(--text-dim);
            font-size: 12px;
            border-top: 1px solid var(--border);
            margin-top: 40px;
        }

        .footer-link {
            color: var(--bitcoin-orange);
            text-decoration: none;
            margin: 0 10px;
        }

        .footer-link:hover {
            text-decoration: underline;
        }

        /* Mobile Enhancements */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            .header {
                padding: 15px;
            }

            .logo {
                font-size: 24px;
            }

            .wallet-bar {
                justify-content: center;
            }

            .chess-board {
                max-width: 100vw;
                max-height: 50vh;
                font-size: 24px;
            }

            .chess-square {
                min-height: 40px;
                min-width: 40px;
            }

            button {
                padding: 15px 20px;
                font-size: 16px; /* Larger for touch */
            }

            input {
                padding: 15px;
                font-size: 16px;
            }

            .card {
                padding: 15px;
            }

            .grid {
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <div class="logo">‚ö° CROSSREALM</div>
            <div class="tagline">On-Chain Chess ‚Ä¢ Powered by Bitcoin & Core</div>
            
            <div class="wallet-bar">
                <div class="wallet-status">
                    <span id="networkStatus">üî¥ Not Connected</span>
                    <span id="walletAddress" class="wallet-address"></span>
                </div>
                <div style="display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;">
                    <button id="connectBtn" onclick="connectWallet()">Connect Wallet</button>
                    <button id="disconnectBtn" class="disconnect-btn" onclick="disconnectWallet()" style="display: none; padding: 12px 20px;">Disconnect</button>
                </div>
            </div>
        </div>

        <!-- Alerts -->
        <div id="alertArea"></div>

        <!-- Main Grid -->
        <div class="grid">
            <!-- Create Game -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">‚öîÔ∏è Create Game</div>
                </div>
                
                <div class="form-group">
                    <label>Stake Amount</label>
                    <input type="number" id="stakeAmount" placeholder="0.1 tCORE2" step="0.01" min="0.01" value="0.1">
                    <small style="color: var(--text-dim); font-size: 11px; display: block; margin-top: 5px;">
                        Min: 0.01 tCORE2 ‚Ä¢ Max: 100 tCORE2
                    </small>
                </div>

                <button onclick="createGame()" id="createBtn" disabled style="width: 100%;">
                    Create Chess Game
                </button>
            </div>

            <!-- Chess Board -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">‚ôüÔ∏è Game Board</div>
                </div>
                
                <div id="chessBoardContainer">
                    <p style="text-align: center; color: var(--text-dim); padding: 40px;">
                        Create or join a game to play
                    </p>
                </div>
                <div id="gameControls" class="game-controls hidden">
                    <div id="playerColor" class="player-color"></div>
                    <div id="gameStatus" class="game-status"></div>
                    <button id="resignBtn" class="resign-btn hidden" onclick="resignGame(currentGameId)" style="width: 100%;">Resign Game</button>
                    <button id="claimBtn" class="claim-btn hidden" onclick="claimTimeout(currentGameId)" style="width: 100%;">Claim Timeout Win</button>
                </div>
            </div>

            <!-- Available Games -->
            <div class="card">
                <div class="card-header">
                    <div class="card-title">üéØ Available Games</div>
                </div>
                
                <button onclick="loadPendingGames()" style="width: 100%; margin-bottom: 15px;">
                    Refresh
                </button>
                
                <div class="game-list" id="gamesList">
                    <p style="text-align: center; color: var(--text-dim); padding: 20px;">
                        Connect wallet to see games
                    </p>
                </div>
            </div>
        </div>

        <!-- My Games -->
        <div class="card">
            <div class="card-header">
                <div class="card-title">üìä My Games</div>
            </div>
            
            <button onclick="loadMyGames()" style="margin-bottom: 15px;">
                Refresh My Games
            </button>
            
            <div class="game-list" id="myGamesList">
                <p style="text-align: center; color: var(--text-dim);">
                    Connect wallet to see your games
                </p>
            </div>
        </div>

        <!-- Footer -->
        <div class="footer">
            <div>CrossRealm ¬© 2025 ‚Ä¢ Built on Core Blockchain</div>
            <div style="margin-top: 10px;">
                <a href="#" class="footer-link">Docs</a>
                <a href="#" class="footer-link">Twitter</a>
                <a href="#" class="footer-link">Discord</a>
            </div>
        </div>
    </div>

    <script>
        // ============ CONFIGURATION ============
        
        const CONTRACT_ADDRESS = "0x014D3817f86F175B512f31c014BcEcDe32Ac9bDA";
        
        const CORE_TESTNET = {
            chainId: "0x45a",  // Fixed: Core Testnet2 (1114 decimal)
            chainName: "Core Blockchain Testnet2",
            rpcUrls: ["https://rpc.test2.btcs.network"],
            blockExplorerUrls: ["https://scan.test2.btcs.network"],
            nativeCurrency: {
                name: "tCORE2",
                symbol: "tCORE2",
                decimals: 18
            }
        };

        const CONTRACT_ABI = [
            "function createGame() payable returns (uint256)",
            "function joinGame(uint256 gameId) payable",
            "function makeMove(uint256 gameId, uint8 from, uint8 to)",
            "function resign(uint256 gameId)",
            "function claimTimeout(uint256 gameId)",
            "function getGame(uint256 gameId) view returns (tuple(address player1, address player2, uint256 stake, address currentTurn, uint8[64] board, uint16 moveCount, uint256 lastMoveTime, address winner, uint8 status))",
            "function getBoard(uint256 gameId) view returns (uint8[64])",
            "function getPlayerGames(address player) view returns (uint256[])",
            "function getPendingGames(uint256 limit) view returns (uint256[])",
            "event GameCreated(uint256 indexed gameId, address indexed player1, uint256 stake)",
            "event MoveMade(uint256 indexed gameId, address indexed player, uint8 from, uint8 to)"
        ];

        // Chess piece unicode symbols
        const PIECE_SYMBOLS = {
            0: '',
            1: '‚ôô', 2: '‚ôò', 3: '‚ôó', 4: '‚ôñ', 5: '‚ôï', 6: '‚ôî',
            7: '‚ôü', 8: '‚ôû', 9: '‚ôù', 10: '‚ôú', 11: '‚ôõ', 12: '‚ôö'
        };

        // ============ STATE ============
        
        let provider, signer, contract, userAddress;
        let currentGameId = null;
        let selectedSquare = null;
        let currentGame = null;  // Store full game data

        // ============ WALLET CONNECTION ============
        
        async function connectWallet() {
            if (typeof window.ethereum === 'undefined') {
                showAlert('Please install MetaMask or Core Wallet!', 'error');
                return;
            }

            try {
                const accounts = await window.ethereum.request({ 
                    method: 'eth_requestAccounts' 
                });
                
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: CORE_TESTNET.chainId }],
                    });
                } catch (switchError) {
                    if (switchError.code === 4902) {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [CORE_TESTNET],
                        });
                    }
                }

                provider = new ethers.providers.Web3Provider(window.ethereum);
                signer = provider.getSigner();
                userAddress = accounts[0];

                contract = new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signer);

                document.getElementById('networkStatus').textContent = 'üü¢ Core Testnet2';
                document.getElementById('walletAddress').textContent = 
                    userAddress.slice(0, 6) + '...' + userAddress.slice(-4);
                document.getElementById('connectBtn').style.display = 'none';
                document.getElementById('disconnectBtn').style.display = 'inline-block';
                document.getElementById('createBtn').disabled = false;

                showAlert('Connected to Core Testnet2!', 'success');

                loadPendingGames();
                loadMyGames();

            } catch (error) {
                console.error('Connection error:', error);
                showAlert('Failed to connect: ' + error.message, 'error');
            }
        }

        // ============ DISCONNECT FUNCTION ============
        
        async function disconnectWallet() {
            if (provider) {
                try {
                    await provider.send('wallet_revokePermissions', [{ eth_accounts: {} }]);
                    window.ethereum.removeAllListeners();
                } catch (error) {
                    console.error('Disconnect error:', error);
                }
            }
            
            // Reset state
            provider = null;
            signer = null;
            contract = null;
            userAddress = null;
            currentGameId = null;
            currentGame = null;
            selectedSquare = null;
            
            // Update UI
            document.getElementById('networkStatus').textContent = 'üî¥ Not Connected';
            document.getElementById('walletAddress').textContent = '';
            document.getElementById('connectBtn').style.display = 'inline-block';
            document.getElementById('disconnectBtn').style.display = 'none';
            document.getElementById('createBtn').disabled = true;
            
            // Clear boards and lists
            document.getElementById('chessBoardContainer').innerHTML = 
                '<p style="text-align: center; color: var(--text-dim); padding: 40px;">Create or join a game to play</p>';
            document.getElementById('gameControls').classList.add('hidden');
            document.getElementById('gamesList').innerHTML = 
                '<p style="text-align: center; color: var(--text-dim); padding: 20px;">Connect wallet to see games</p>';
            document.getElementById('myGamesList').innerHTML = 
                '<p style="text-align: center; color: var(--text-dim);">Connect wallet to see your games</p>';
            
            showAlert('Wallet disconnected', 'info');
        }

        // ============ GAME FUNCTIONS ============
        
        async function createGame() {
            if (!contract) return;

            // Dynamic chain ID check
            const network = await provider.getNetwork();
            const expectedChainId = parseInt(CORE_TESTNET.chainId, 16);  // 1114 for Testnet2
            if (network.chainId !== expectedChainId) {
                showAlert(`Wrong network! Please switch to Core Testnet2 (ID: ${expectedChainId})`, 'error');
                try {
                    await window.ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: CORE_TESTNET.chainId }],
                    });
                } catch (e) {
                    if (e.code === 4902) {
                        await window.ethereum.request({
                            method: 'wallet_addEthereumChain',
                            params: [CORE_TESTNET],
                        });
                    }
                }
                return;
            }

            const stake = document.getElementById('stakeAmount').value;
            
            if (!stake || parseFloat(stake) < 0.01) {
                showAlert('Minimum stake is 0.01 tCORE2', 'error');
                return;
            }

            try {
                showAlert('Creating game...', 'info');

                const tx = await contract.createGame({
                    value: ethers.utils.parseEther(stake),
                    gasLimit: 500000
                });

                showAlert('Transaction submitted...', 'info');
                const receipt = await tx.wait();
                
                if (receipt.status === 1) {
                    showAlert('Game created successfully! ‚úÖ', 'success');
                    
                    setTimeout(() => {
                        loadPendingGames();
                        loadMyGames();
                    }, 3000);
                } else {
                    showAlert('Transaction failed!', 'error');
                }

            } catch (error) {
                console.error('Create game error:', error);
                
                let errorMsg = 'Failed to create game';
                if (error.message.includes('insufficient funds')) {
                    errorMsg = 'Insufficient tCORE2 balance';
                } else if (error.message.includes('user rejected')) {
                    errorMsg = 'Transaction cancelled';
                } else if (error.reason) {
                    errorMsg = error.reason;
                }
                
                showAlert(errorMsg, 'error');
            }
        }

        async function joinGame(gameId, stake) {
            if (!contract) return;

            try {
                showAlert('Joining game...', 'info');

                const tx = await contract.joinGame(gameId, {
                    value: ethers.utils.parseEther(stake),
                    gasLimit: 500000
                });

                showAlert('Transaction submitted...', 'info');
                await tx.wait();

                showAlert('Joined game!', 'success');
                currentGameId = gameId;

                setTimeout(() => {
                    loadPendingGames();
                    loadMyGames();
                    loadGame(gameId);
                }, 2000);

            } catch (error) {
                console.error(error);
                showAlert('Failed to join: ' + error.message, 'error');
            }
        }

        async function loadGame(gameId) {
            if (!contract) return;

            try {
                currentGameId = gameId;  // Ensure currentGameId is set
                currentGame = await contract.getGame(gameId);
                renderBoard(currentGame.board, gameId, currentGame);
                updateGameControls(currentGame);
            } catch (error) {
                console.error(error);
            }
        }

        function renderBoard(board, gameId, game) {
            const container = document.getElementById('chessBoardContainer');
            const boardHTML = '<div class="chess-board">' + 
                Array.from({ length: 64 }, (_, i) => {
                    const row = Math.floor(i / 8);
                    const col = i % 8;
                    const isLight = (row + col) % 2 === 0;
                    const piece = PIECE_SYMBOLS[board[i] || 0];
                    
                    // Add touch support for mobile
                    return `<div class="chess-square ${isLight ? 'light' : 'dark'}" 
                                 onclick="selectSquare(${i}, ${gameId})" 
                                 ontouchstart="selectSquare(${i}, ${gameId})"
                                 data-square="${i}">
                                ${piece}
                            </div>`;
                }).join('') + 
            '</div>';
            
            const winnerText = game.winner === ethers.constants.AddressZero ? '' : 
                `Winner: ${game.winner.toLowerCase() === userAddress.toLowerCase() ? 'You!' : 'Opponent'}`;
            
            const info = `
                <div style="margin-top: 20px; text-align: center;">
                    <div>Game #${gameId}</div>
                    <div style="margin-top: 10px;">
                        ${game.status === 1 ? (game.currentTurn.toLowerCase() === userAddress.toLowerCase() ? 
                            '<span style="color: var(--success);">Your Turn</span>' : 
                            '<span style="color: var(--text-dim);">Opponent\'s Turn</span>') : 
                        `<span style="color: ${game.status === 2 ? 'var(--success)' : 'var(--error)'};">Game ${['Pending', 'Active', 'Completed', 'Cancelled'][game.status]}</span>`}
                    </div>
                    ${winnerText ? `<div style="margin-top: 10px; font-weight: bold;">${winnerText}</div>` : ''}
                </div>
            `;
            
            container.innerHTML = boardHTML + info;
        }

        function updateGameControls(game) {
            const controls = document.getElementById('gameControls');
            const statusEl = document.getElementById('gameStatus');
            const playerColorEl = document.getElementById('playerColor');
            const resignBtn = document.getElementById('resignBtn');
            const claimBtn = document.getElementById('claimBtn');

            controls.classList.remove('hidden');
            statusEl.textContent = `Status: ${['Pending', 'Active', 'Completed', 'Cancelled'][game.status]}`;

            // Determine player color
            let playerColor = '';
            if (game.player1.toLowerCase() === userAddress.toLowerCase()) {
                playerColor = 'You are White (Player 1)';
            } else if (game.player2 && game.player2.toLowerCase() === userAddress.toLowerCase()) {
                playerColor = 'You are Black (Player 2)';
            } else {
                playerColor = 'Not in this game';
            }
            playerColorEl.textContent = playerColor;

            // Hide buttons by default
            resignBtn.classList.add('hidden');
            claimBtn.classList.add('hidden');

            if (game.status === 1) {  // Active game
                // Resign button for both players
                resignBtn.classList.remove('hidden');

                // Claim timeout if it's your turn and timeout exceeded (assume 24h = 86400s)
                const now = Math.floor(Date.now() / 1000);
                const timeout = 86400;  // 24 hours
                if (game.currentTurn.toLowerCase() === userAddress.toLowerCase() && 
                    now > game.lastMoveTime.toNumber() + timeout) {
                    claimBtn.classList.remove('hidden');
                }
            }
        }

        async function selectSquare(square, gameId) {
            if (!currentGame || currentGame.status !== 1 || currentGame.currentTurn.toLowerCase() !== userAddress.toLowerCase()) {
                showAlert('Not your turn or game not active', 'error');
                return;
            }

            if (selectedSquare === null) {
                selectedSquare = square;
                document.querySelectorAll('.chess-square')[square].classList.add('selected');
            } else {
                if (selectedSquare === square) {
                    document.querySelectorAll('.chess-square')[square].classList.remove('selected');
                    selectedSquare = null;
                } else {
                    await makeMove(gameId, selectedSquare, square);
                    document.querySelectorAll('.chess-square').forEach(sq => sq.classList.remove('selected'));
                    selectedSquare = null;
                }
            }
        }

        async function makeMove(gameId, from, to) {
            if (!contract) return;

            try {
                showAlert('Making move...', 'info');

                // Mobile alert for signing
                if (window.innerWidth <= 768) {
                    showAlert('Confirm the signature in MetaMask (check your notifications)', 'info');
                }

                const tx = await contract.makeMove(gameId, from, to, {
                    gasLimit: 300000
                });
                showAlert('Transaction submitted...', 'info');
                await tx.wait();

                showAlert('Move made!', 'success');
                
                setTimeout(() => loadGame(gameId), 2000);

            } catch (error) {
                console.error(error);
                showAlert('Invalid move: ' + error.message, 'error');
            }
        }

        async function resignGame(gameId) {
            if (!contract || !gameId) {
                showAlert('No active game selected', 'error');
                return;
            }

            try {
                showAlert('Resigning game...', 'info');
                const tx = await contract.resign(gameId, { gasLimit: 200000 });
                await tx.wait();
                showAlert('Game resigned. Opponent wins!', 'info');
                setTimeout(() => loadGame(gameId), 2000);
            } catch (error) {
                console.error(error);
                showAlert('Resign failed: ' + (error.reason || error.message), 'error');
            }
        }

        async function claimTimeout(gameId) {
            if (!contract || !gameId) {
                showAlert('No active game selected', 'error');
                return;
            }

            try {
                showAlert('Claiming timeout win...', 'info');
                const tx = await contract.claimTimeout(gameId, { gasLimit: 200000 });
                await tx.wait();
                showAlert('Timeout claimed! You win!', 'success');
                setTimeout(() => loadGame(gameId), 2000);
            } catch (error) {
                console.error(error);
                showAlert('Claim failed: ' + (error.reason || error.message), 'error');
            }
        }

        async function loadPendingGames() {
            if (!contract) return;

            const list = document.getElementById('gamesList');
            list.innerHTML = '<div class="spinner"></div>';

            try {
                const gameIds = await contract.getPendingGames(10);
                
                if (gameIds.length === 0) {
                    list.innerHTML = '<p style="text-align:center;color:var(--text-dim);padding:20px;">No games available. Create one!</p>';
                    return;
                }

                let html = '';
                for (const id of gameIds) {
                    try {
                        const game = await contract.getGame(id);
                        const stake = ethers.utils.formatEther(game.stake);
                        
                        html += `
                            <div class="game-item">
                                <div class="game-meta">
                                    <span class="game-id">Game #${id.toString()}</span>
                                    <span class="game-stake">${stake} tCORE2</span>
                                </div>
                                <div class="game-player" style="margin-top: 5px;">
                                    Creator: ${game.player1.slice(0, 10)}...
                                </div>
                                <button onclick="joinGame(${id}, '${stake}')" style="width:100%;margin-top:10px;">
                                    Join Game (${stake} tCORE2)
                                </button>
                            </div>
                        `;
                    } catch (e) {
                        console.error('Error loading game', id, e);
                    }
                }
                
                if (html) {
                    list.innerHTML = html;
                } else {
                    list.innerHTML = '<p style="text-align:center;color:var(--text-dim);padding:20px;">No valid games found</p>';
                }

            } catch (error) {
                console.error('Load pending games error:', error);
                list.innerHTML = '<p style="text-align:center;color:var(--error);padding:20px;">Error loading games. Try refresh.</p>';
            }
        }

        async function loadMyGames() {
            if (!contract) return;

            try {
                const gameIds = await contract.getPlayerGames(userAddress);
                const list = document.getElementById('myGamesList');
                
                if (gameIds.length === 0) {
                    list.innerHTML = '<p style="text-align:center;color:var(--text-dim);">No games yet</p>';
                    return;
                }

                let html = '';
                for (const id of gameIds) {
                    const game = await contract.getGame(id);
                    const stake = ethers.utils.formatEther(game.stake);
                    const status = ['Pending', 'Active', 'Completed', 'Cancelled'][game.status];
                    
                    html += `
                        <div class="game-item">
                            <div class="game-meta">
                                <span class="game-id">Game #${id.toString()}</span>
                                <span class="game-stake">${status}</span>
                            </div>
                            <div style="margin-top: 10px;">Stake: ${stake} tCORE2</div>
                            ${game.status === 1 ? 
                                `<button onclick="loadGame(${id})" style="width:100%;margin-top:10px;">
                                    View Game
                                </button>` : ''}
                        </div>
                    `;
                }
                
                list.innerHTML = html;

            } catch (error) {
                console.error(error);
            }
        }

        function showAlert(message, type) {
            const area = document.getElementById('alertArea');
            const alert = document.createElement('div');
            alert.className = `alert alert-${type}`;
            alert.textContent = message;
            
            area.appendChild(alert);
            
            setTimeout(() => alert.remove(), 5000);
        }

        // Auto-refresh
        setInterval(() => {
            if (contract) {
                loadPendingGames();
                loadMyGames();
                if (currentGameId && currentGame) {
                    loadGame(currentGameId);  // Reload to update status
                }
            }
        }, 15000);
    </script>
</body>
</html>
